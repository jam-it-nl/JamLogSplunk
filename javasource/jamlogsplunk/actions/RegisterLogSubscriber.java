// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package jamlogsplunk.actions;

import java.net.URL;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import com.mendix.core.Core;
import com.mendix.logging.ILogNode;
import com.mendix.logging.LogLevel;
import com.mendix.logging.LogMessage;
import com.mendix.logging.LogSubscriber;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.webui.CustomJavaAction;
import com.splunk.logging.HttpEventCollectorErrorHandler;
import com.splunk.logging.HttpEventCollectorEventInfo;
import com.splunk.logging.HttpEventCollectorSender;
import jamlogsplunk.proxies.constants.Constants;

/**
 * HTTP Event Collector is turned off by default in Splunk Enterprise and Splunk Cloud. Before you can send events to HTTP Event Collector, you must enable it. Ask your Splunk administrator to enable HTTP Event Collector, or see Set up and use HTTP Event Collector in Splunk Web in Getting Data In.
 * 
 * Once HTTP Event Collector is enabled, you need the following information before you can log events:
 * 
 * Url: The hostname and port of the Splunk Enterprise or Splunk Cloud server. The default port number is 8088.
 * Token: A valid, enabled token. An HTTP Event Collector token is a string that identifies a client (your Java app) to HTTP Event Collector. Your Splunk administrator or a designated token administrator can generate and provide a valid token.
 */
public class RegisterLogSubscriber extends CustomJavaAction<java.lang.Void>
{
	private java.lang.String url;
	private java.lang.String token;
	private java.lang.String channel;
	private java.lang.String logLevel;

	public RegisterLogSubscriber(IContext context, java.lang.String url, java.lang.String token, java.lang.String channel, java.lang.String logLevel)
	{
		super(context);
		this.url = url;
		this.token = token;
		this.channel = channel;
		this.logLevel = logLevel;
	}

	@java.lang.Override
	public java.lang.Void executeAction() throws Exception
	{
		// BEGIN USER CODE
		String applicationRootUrl = Core.getConfiguration().getApplicationRootUrl();
		URL url = new URL(applicationRootUrl);

		Set<String> publicConstants = Core.getConfiguration().getPublicConstants();

		if (!Constants.getEnableOnLocalhost() && url.getHost().equals("localhost")) {
			return null;
		}

		LogLevel mendixLogLevel = LogLevel.valueOf(this.logLevel);

		Core.registerLogSubscriber(new MendixObjectLogSubscriber(mendixLogLevel));
		logger.warn("Registered Splunk logger on level " + this.logLevel);
		return null;
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "RegisterLogSubscriber";
	}

	// BEGIN EXTRA CODE
	private ILogNode logger = Core.getLogger("JamLogSplunk");

	private class MendixObjectLogSubscriber extends LogSubscriber {

		private HttpEventCollectorSender httpEventCollectorSender;

		public MendixObjectLogSubscriber(LogLevel logLevel) {
			super(MendixObjectLogSubscriber.class.getName(), logLevel);

			String type = null;
			String sendMode = null;
			long batchInterval = 0;
			long batchCount = 0;
			long batchSize = 0;
			Map<String, String> metadata = new HashMap<>();
			HttpEventCollectorSender.TimeoutSettings timeoutSettings = new HttpEventCollectorSender.TimeoutSettings();

			this.httpEventCollectorSender = new HttpEventCollectorSender(url, token, channel, type, batchInterval, batchCount, batchSize, sendMode, metadata, timeoutSettings);
			this.httpEventCollectorSender.disableCertificateValidation();

			HttpEventCollectorErrorHandler.onError(new HttpEventCollectorErrorHandler.ErrorCallback() {
				@Override
				public void error(List<HttpEventCollectorEventInfo> httpEventCollectorEventInfo, Exception exception) {
					System.err.println(exception.getMessage());
					exception.printStackTrace(System.err);

					logger.error(exception.getMessage(), exception);
				}
			});
		}

		@Override
		public void processMessage(LogMessage logMessage) {
			if (logMessage.node != null && logMessage.node.name() != null) {
				if (logMessage.node.name().equals("Connector")) {
					return;
				}
			}

			this.httpEventCollectorSender.send(System.currentTimeMillis(), convertLevel(logMessage), convertMessage(logMessage.message), convertNode(logMessage.node), null, null, convertExceptionMessage(logMessage.cause), logMessage.cause);
		}

		private String convertLevel(LogMessage logMessage) {
			if (logMessage == null) {
				return "";
			}

			if (logMessage.level == null) {
				return "";
			}

			return logMessage.level.toString();
		}

		private String convertExceptionMessage(Throwable cause) {
			if (cause == null) {
				return "";
			}

			if (cause.getMessage() == null) {
				return "";
			}

			return cause.getMessage();
		}

		private String convertNode(ILogNode node) {
			if (node == null) {
				return "";
			}
			final String nodeName = node.name();
			if ((nodeName != null) && (nodeName.length() > 128)) {
				return nodeName.substring(0, 128);
			}
			return nodeName;
		}

		private String convertMessage(Object message) {
			if (message == null) {
				return "";
			}
			return message.toString();
		}
	}

	// END EXTRA CODE
}
