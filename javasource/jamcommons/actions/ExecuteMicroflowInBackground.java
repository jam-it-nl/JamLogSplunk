// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package jamcommons.actions;

import java.util.HashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.atomic.AtomicLong;
import org.apache.commons.lang3.StringUtils;
import com.mendix.core.Core;
import com.mendix.logging.ILogNode;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import com.mendix.systemwideinterfaces.core.ISession;
import com.mendix.webui.CustomJavaAction;
import jamcommons.impl.SerialExecutor;

/**
 * This action allows an microflow to be executed independently from this microflow. 
 * 
 * This might be useful to model for example your own batching system, or to run a microflow in its own transaction. The microflow is delayed for at least 200ms and then run with low priority in a system context. Since the microflow run in its own transaction, it is not affected with rollbacks (due to exceptions) or commits in this microflow. 
 * 
 * Invocations to this method are guaranteed to be run in FIFO order, only one microflow is run at a time. 
 * 
 * - The microflowname specifies the fully qualified name of the microflow (case sensitive) e.g.: 'MyFirstModule.MyFirstMicroflow'. 
 * - The context object specifies an argument that should be passed to the microflow if applicable. Only zero or one argument are supported. Note that editing this object in both microflows might lead to unexpected behavior.
 * - The queue name is used to group all microflows to be executed in FIFO into different groups, so you are able to execute multiple background tasks independent of each other. Leave empty to use a defauult queue.
 *  
 * Returns true if scheduled successfully.
 * 
 * $currentSession is availible in this version. The microflow is run as an guest session with a sudo context.
 */
public class ExecuteMicroflowInBackground extends CustomJavaAction<java.lang.Boolean>
{
	private java.lang.String microflow;
	private IMendixObject contextObject;
	private java.lang.String queue;

	public ExecuteMicroflowInBackground(IContext context, java.lang.String microflow, IMendixObject contextObject, java.lang.String queue)
	{
		super(context);
		this.microflow = microflow;
		this.contextObject = contextObject;
		this.queue = queue;
	}

	@java.lang.Override
	public java.lang.Boolean executeAction() throws Exception
	{
		// BEGIN USER CODE
		final String defaultQueue = StringUtils.isEmpty(this.queue) ? this.getClass().getSimpleName() : this.queue;
		SerialExecutor.getInstance(defaultQueue).execute(new Runnable() {

			@Override
			public void run() {
				try {
					ISession newSession = Core.initializeGuestSession();
					IContext newContext = newSession.createContext().createSudoClone();

					if (ExecuteMicroflowInBackground.this.contextObject != null) {
						Core.executeAsync(newContext, ExecuteMicroflowInBackground.this.microflow, true, ExecuteMicroflowInBackground.this.contextObject).get();
					} else {
						Core.executeAsync(newContext, ExecuteMicroflowInBackground.this.microflow, true, new HashMap<String, Object>()).get();
					}

					newSession.destroy();

				} catch (Exception e) {
					throw new RuntimeException("[" + defaultQueue + "] Failed to run Async: " + ExecuteMicroflowInBackground.this.microflow + ": " + e.getMessage(), e);
				}

			}

		});
		return true;
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "ExecuteMicroflowInBackground";
	}

	// BEGIN EXTRA CODE
	static class MFSerialExecutor {
		private static final ILogNode LOG = Core.getLogger("communitycommons");

		private static MFSerialExecutor _instance = new MFSerialExecutor();

		private final AtomicLong tasknr = new AtomicLong();
		private final ExecutorService executor;

		public static MFSerialExecutor instance() {
			return _instance;
		}

		private MFSerialExecutor() {
			executor = Executors.newSingleThreadExecutor(new ThreadFactory() {

				// Default thread factory takes care of setting the proper
				// thread context
				private final ThreadFactory defaultFactory = Executors.defaultThreadFactory();

				@Override
				public Thread newThread(Runnable runnable) {
					Thread t = defaultFactory.newThread(runnable);
					t.setPriority(Thread.MIN_PRIORITY);
					t.setName("CommunityCommons background pool executor thread");
					return t;
				}

			});
		}

		public void execute(final Runnable command) {
			if (command == null) {
				throw new NullPointerException("command");
			}

			final long currenttasknr = tasknr.incrementAndGet();
			LOG.debug("[RunMicroflowAsyncInQueue] Scheduling task #" + currenttasknr);

			executor.submit(new Runnable() {
				@Override
				public void run() {
					LOG.debug("[RunMicroflowAsyncInQueue] Running task #" + currenttasknr);
					try {
						command.run();
					} catch (RuntimeException e) {
						LOG.error("[RunMicroflowAsyncInQueue] Execution of task #" + currenttasknr + " failed: " + e.getMessage(), e);
						throw e; // single thread executor will continue, even
									// if an exception is thrown.
					}
					LOG.debug("[RunMicroflowAsyncInQueue] Completed task #" + currenttasknr + ". Tasks left: " + (tasknr.get() - currenttasknr));
				}
			});
		}
	}
	// END EXTRA CODE
}
